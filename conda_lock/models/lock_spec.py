import hashlib
import json
import pathlib
import typing
import warnings

from collections import defaultdict
from typing import Any, Dict, List, NamedTuple, Optional, Set, Tuple, Union

from pydantic import BaseModel, Field, field_validator
from typing_extensions import Literal

from conda_lock.models import StrictModel
from conda_lock.models.channel import Channel
from conda_lock.models.pip_repository import PipRepository
from conda_lock.virtual_package import FakeRepoData


class _BaseDependency(StrictModel):
    name: str
    manager: Literal["conda", "pip"] = "conda"
    category: str = "main"
    extras: List[str] = []
    markers: Optional[str] = None

    @field_validator("extras")
    @classmethod
    def sorted_extras(cls, v: List[str]) -> List[str]:
        return sorted(v)


class VersionedDependency(_BaseDependency):
    version: str
    build: Optional[str] = None
    conda_channel: Optional[str] = None
    hash: Optional[str] = None


class URLDependency(_BaseDependency):
    url: str
    hashes: List[str]


class VCSDependency(_BaseDependency):
    source: str
    vcs: str
    rev: Optional[str] = None


Dependency = Union[VersionedDependency, URLDependency, VCSDependency]


class Package(StrictModel):
    url: str
    hash: str


class PoetryMappedDependencySpec(StrictModel):
    url: Optional[str] = None
    manager: Literal["conda", "pip"]
    extras: List
    markers: Optional[str] = None
    poetry_version_spec: Optional[str] = None


class LockSpecification(BaseModel):
    dependencies: Dict[str, List[Dependency]]
    # TODO: Should we store the auth info in here?
    channels: List[Channel]
    sources: List[pathlib.Path]
    pip_repositories: List[PipRepository] = Field(default_factory=list)
    allow_pypi_requests: bool = True

    @property
    def platforms(self) -> List[str]:
        return list(self.dependencies.keys())

    def content_hash(
        self, virtual_package_repo: Optional[FakeRepoData]
    ) -> Dict[str, str]:
        return {
            platform: self.content_hash_for_platform(platform, virtual_package_repo)
            for platform in self.platforms
        }

    def content_hash_for_platform(
        self, platform: str, virtual_package_repo: Optional[FakeRepoData]
    ) -> str:
        data = {
            "channels": [c.model_dump_json() for c in self.channels],
            "specs": [
                p.model_dump()
                for p in sorted(
                    self.dependencies[platform], key=lambda p: (p.manager, p.name)
                )
            ],
        }
        if self.pip_repositories:
            data["pip_repositories"] = [
                repo.model_dump_json() for repo in self.pip_repositories
            ]
        if virtual_package_repo is not None:
            vpr_data = virtual_package_repo.all_repodata
            data["virtual_package_hash"] = {
                "noarch": vpr_data.get("noarch", {}),
                **{platform: vpr_data.get(platform, {})},
            }

        env_spec = json.dumps(data, sort_keys=True)
        return hashlib.sha256(env_spec.encode("utf-8")).hexdigest()

    @field_validator("channels", mode="before")
    @classmethod
    def validate_channels(cls, v: List[Union[Channel, str]]) -> List[Channel]:
        for i, e in enumerate(v):
            if isinstance(e, str):
                e = Channel.from_string(e)
                v[i] = e
            if e.url == "nodefaults":
                raise ValueError("nodefaults channel is not allowed, ref #418")
        return typing.cast(List[Channel], v)

    @field_validator("pip_repositories", mode="before")
    @classmethod
    def validate_pip_repositories(
        cls, value: List[Union[PipRepository, str]]
    ) -> List[PipRepository]:
        for index, repository in enumerate(value):
            if isinstance(repository, str):
                value[index] = PipRepository.from_string(repository)
        return typing.cast(List[PipRepository], value)


class DepKey1(NamedTuple):
    name: str
    category: str
    platform: str
    manager: str


class DepKey2(NamedTuple):
    name: str
    category: str
    manager: str


class TomlKey(NamedTuple):
    category: str
    platform: Optional[str]
    manager: str


class DepWithPlatform(NamedTuple):
    dep: Dependency
    platform: str


def render_pixi_toml(
    *,
    lock_spec: LockSpecification,
    project_name: str = "project-name-placeholder",
) -> List[str]:
    all_platforms = lock_spec.dependencies.keys()

    all_categories: Set[str] = set()
    for platform in all_platforms:
        for dep in lock_spec.dependencies[platform]:
            all_categories.add(dep.category)
    if {"main", "default"} <= all_categories:
        raise ValueError("Cannot have both 'main' and 'default' as categories/extras")

    result: List[str] = [
        "# This file was generated by conda-lock for the pixi environment manager.",
        "# For more information, see <https://github.com/conda/conda-lock> "
        "and <https://pixi.sh>.",
        "# Source files:",
    ]
    for source in lock_spec.sources:
        result.append(f"# - {source}")
    result.extend(
        [
            "",
            "[project]",
            f'name = "{project_name}"',
            f"platforms = {list(all_platforms)}",
        ]
    )
    channels: List[str] = [channel.url for channel in lock_spec.channels]
    for channel in lock_spec.channels:
        if channel.used_env_vars:
            warnings.warn(
                f"Channel {channel.url} uses environment variables "
                "which are not implemented"
            )
    result.append(f"channels = {channels}")
    result.append("")

    sorted_categories = sorted(all_categories)
    if "main" in sorted_categories:
        sorted_categories.remove("main")
        sorted_categories.insert(0, "main")
    if "default" in sorted_categories:
        sorted_categories.remove("default")
        sorted_categories.insert(0, "default")

    indexed_deps: Dict[DepKey1, Dependency] = {}
    for platform in all_platforms:
        deps = lock_spec.dependencies[platform]
        for dep in deps:
            category = dep.category
            key1 = DepKey1(
                name=dep.name, category=category, platform=platform, manager=dep.manager
            )
            if key1 in indexed_deps:
                raise ValueError(
                    f"Duplicate dependency {key1}: {dep}, {indexed_deps[key1]}"
                )
            indexed_deps[key1] = dep

    arranged_deps = arrange_for_toml(
        indexed_deps=indexed_deps, all_platforms=set(all_platforms)
    )
    for key, deps_by_name in arranged_deps.items():
        result.append(toml_header(key))
        for name, dep in deps_by_name.items():
            pixi_spec = make_pixi_spec(dep)
            result.append(f"{name} = {pixi_spec}")
        result.append("")
    return result


def make_pixi_spec(dep: Dependency) -> str:
    matchspec: Dict[str, Any] = {}
    if isinstance(dep, VersionedDependency):
        matchspec["version"] = dep.version or "*"
        if dep.build is not None:
            matchspec["build"] = dep.build
        if dep.hash is not None:
            raise NotImplementedError(f"Hash not yet supported in {dep}")
        if dep.conda_channel is not None:
            matchspec["channel"] = dep.conda_channel
        if dep.extras:
            if dep.extras and dep.manager == "conda":
                warnings.warn(f"Extras not supported in Conda dep {dep}")
            else:
                matchspec["extras"] = dep.extras
        if len(matchspec) == 1:
            return f'"{matchspec["version"]}"'
        else:
            return json.dumps(matchspec)
    elif isinstance(dep, URLDependency):
        raise NotImplementedError(f"URL not yet supported in {dep}")
    elif isinstance(dep, VCSDependency):
        raise NotImplementedError(f"VCS not yet supported in {dep}")
    else:
        raise ValueError(f"Unknown dependency type {dep}")


def extract_platform_independent_deps(
    *, indexed_deps: Dict[DepKey1, Dependency], num_platforms: int
) -> tuple[Dict[DepKey2, Dependency], Dict[DepKey1, Dependency]]:
    all_platform_deps: Dict[DepKey2, Dependency] = {}
    platform_specific_deps: Dict[DepKey1, Dependency] = {}

    # Collect by platform
    aggregated_deps: Dict[DepKey2, List[DepWithPlatform]] = defaultdict(list)
    for key1, dep in indexed_deps.items():
        key2 = DepKey2(name=key1.name, category=key1.category, manager=key1.manager)
        aggregated_deps[key2].append(DepWithPlatform(dep=dep, platform=key1.platform))

    # Check for all-arch dependencies
    for key2, deps_with_platforms in aggregated_deps.items():
        # It's all-arch if there's a dep for each platform and they're all the same.
        is_allarch = len(deps_with_platforms) == num_platforms and all(
            curr.dep == next.dep
            for curr, next in zip(deps_with_platforms, deps_with_platforms[1:])
        )
        if is_allarch:
            all_platform_deps[key2] = deps_with_platforms[0].dep
        else:
            for dep_with_platform in deps_with_platforms:
                key1 = DepKey1(
                    name=key2.name,
                    category=key2.category,
                    platform=dep_with_platform.platform,
                    manager=key2.manager,
                )
                platform_specific_deps[key1] = dep_with_platform.dep
    return all_platform_deps, platform_specific_deps


def arrange_for_toml(
    *, indexed_deps: Dict[DepKey1, Dependency], all_platforms: Set[str]
) -> Dict[TomlKey, Dict[str, Dependency]]:
    unsorted_result: Dict[TomlKey, Dict[str, Dependency]] = defaultdict(dict)
    all_platform_deps, platform_specific_deps = extract_platform_independent_deps(
        indexed_deps=indexed_deps, num_platforms=len(all_platforms)
    )
    for key1, dep in platform_specific_deps.items():
        toml_key = TomlKey(
            category=key1.category, platform=key1.platform, manager=key1.manager
        )
        if key1.name in unsorted_result[toml_key]:
            preexisting_dep = unsorted_result[toml_key][key1.name]
            raise ValueError(f"Duplicate key {key1} for {dep} and {preexisting_dep}")
        unsorted_result[toml_key][key1.name] = dep
    for key2, dep in all_platform_deps.items():
        toml_key = TomlKey(category=key2.category, platform=None, manager=key2.manager)
        if key2.name in unsorted_result[toml_key]:
            preexisting_dep = unsorted_result[toml_key][key2.name]
            raise ValueError(f"Duplicate key {key2} for {dep} and {preexisting_dep}")
        unsorted_result[toml_key][key2.name] = dep

    alphabetized_result = {
        toml_key: dict(sorted(deps_by_name.items()))
        for toml_key, deps_by_name in unsorted_result.items()
    }
    sorted_result = dict(sorted(alphabetized_result.items(), key=toml_ordering))
    return sorted_result


def toml_ordering(item: Tuple[TomlKey, dict]) -> tuple[str, str, str]:
    """Make an associated key that is totally ordered.

    >>> toml_ordering((TomlKey(category="main", platform=None, manager="conda"), {}))
    ('', '', 'conda')

    >>> toml_ordering(
    ...     (TomlKey(category="main", platform="linux-64", manager="conda"), {})
    ... )
    ('', 'linux-64', 'conda')

    >>> toml_ordering((TomlKey(category="dev", platform=None, manager="pip"), {}))
    ('dev', '', 'pip')
    """
    key = item[0]
    category = key.category
    if category == "main" or category == "default":
        # Make sure "main"/"default" comes first
        category = ""
    # Make sure all-platform comes first
    platform = key.platform if key.platform is not None else ""
    # "conda" before "pip" is easy since it's already alphabetical.
    return category, platform, key.manager


def toml_header(key: TomlKey) -> str:
    """Generate a TOML header for a given key.

    >>> toml_header(TomlKey(category="main", platform=None, manager="conda"))
    '[dependencies]'

    >>> toml_header(TomlKey(category="main", platform="linux-64", manager="conda"))
    '[target.linux-64.dependencies]'

    >>> toml_header(TomlKey(category="main", platform=None, manager="pip"))
    '[pypi-dependencies]'

    >>> toml_header(TomlKey(category="main", platform="linux-64", manager="pip"))
    '[target.linux-64.pypi-dependencies]'

    >>> toml_header(TomlKey(category="dev", platform=None, manager="conda"))
    '[feature.dev.dependencies]'

    >>> toml_header(TomlKey(category="dev", platform="linux-64", manager="conda"))
    '[feature.dev.target.linux-64.dependencies]'

    >>> toml_header(TomlKey(category="dev", platform=None, manager="pip"))
    '[feature.dev.pypi-dependencies]'

    >>> toml_header(TomlKey(category="dev", platform="linux-64", manager="pip"))
    '[feature.dev.target.linux-64.pypi-dependencies]'
    """
    result = "["
    category = key.category
    platform = key.platform
    manager = key.manager
    if category != "main" and category != "default":
        result += f"feature.{category}."
    if platform is not None:
        result += f"target.{platform}."
    if manager == "conda":
        result += "dependencies]"
    elif manager == "pip":
        result += "pypi-dependencies]"
    else:
        raise ValueError(f"Unknown manager {manager}")
    return result
