import json
import warnings

from collections import defaultdict
from typing import Any, Dict, List, NamedTuple, Optional, Set, Tuple

from conda_lock.models.lock_spec import (
    Dependency,
    LockSpecification,
    URLDependency,
    VCSDependency,
    VersionedDependency,
)


class FullDepKey(NamedTuple):
    """A unique key for a dependency in a LockSpecification."""

    name: str
    category: str
    platform: str
    manager: str


class DepKeyNoPlatform(NamedTuple):
    """A key for a dependency in a LockSpecification without a platform."""

    name: str
    category: str
    manager: str


class TomlTableKey(NamedTuple):
    """Represents a key in a pixi.toml table.

    It can be rendered into a TOML header line using `toml_header_line`.

    >>> toml_header_line(
    ...     TomlTableKey(category="dev", platform="linux-64", manager="pip")
    ... )
    '[feature.dev.target.linux-64.pypi-dependencies]'
    """

    category: str
    platform: Optional[str]
    manager: str


class DepWithPlatform(NamedTuple):
    dep: Dependency
    platform: str


def render_pixi_toml(
    *, lock_spec: LockSpecification, project_name: str = "project-name-placeholder"
) -> List[str]:
    """Render a pixi.toml from a LockSpecification as a list of lines."""
    all_platforms = lock_spec.dependencies.keys()
    all_categories: Set[str] = set()
    for platform in all_platforms:
        for dep in lock_spec.dependencies[platform]:
            all_categories.add(dep.category)
    if {"main", "default"} <= all_categories:
        raise ValueError("Cannot have both 'main' and 'default' as categories/extras")

    lines: List[str] = [
        "# This file was generated by conda-lock for the pixi environment manager.",
        "# For more information, see <https://github.com/conda/conda-lock> "
        "and <https://pixi.sh>.",
        "# Source files:",
    ]
    lines.extend(f"# - {source}" for source in lock_spec.sources)
    lines.extend(
        [
            "",
            "[project]",
            f'name = "{project_name}"',
            f"platforms = {list(all_platforms)}",
            "",
        ]
    )

    arranged_deps = arrange_for_toml(lock_spec)
    for key, deps_by_name in arranged_deps.items():
        lines.append(toml_header_line(key))
        lines.extend(toml_dependency_line(dep) for name, dep in deps_by_name.items())
        lines.append("")
    return lines


def toml_dependency_line(dep: Dependency) -> str:
    """Render a conda-lock Dependency as a pixi.toml line as VersionSpec or matchspec.

    The result is suitable for the values used in the `dependencies` or
    `pypi-dependencies` tables of a pixi TOML file.

    >>> toml_dependency_line(VersionedDependency(name="numpy", version="2.1.1"))
    'numpy = "2.1.1"'

    >>> toml_dependency_line(VersionedDependency(name="numpy", version=""))
    'numpy = "*"'

    >>> toml_dependency_line(
    ...     VersionedDependency(
    ...         name="numpy",
    ...         version="2.1.1",
    ...         conda_channel="conda-forge",
    ...         build="py313h4bf6692_0"
    ...     )
    ... )
    'numpy = {"version": "2.1.1", "build": "py313h4bf6692_0", "channel": "conda-forge"}'

    >>> toml_dependency_line(
    ...     VersionedDependency(
    ...         name="xarray",
    ...         version="",
    ...         extras=["io", "parallel"],
    ...         manager="pip",
    ...     )
    ... )
    'xarray = {"version": "*", "extras": ["io", "parallel"]}'
    """
    matchspec: Dict[str, Any] = {}
    if isinstance(dep, VersionedDependency):
        matchspec["version"] = dep.version or "*"
        if dep.build is not None:
            matchspec["build"] = dep.build
        if dep.hash is not None:
            raise NotImplementedError(f"Hash not yet supported in {dep}")
        if dep.conda_channel is not None:
            matchspec["channel"] = dep.conda_channel
        if dep.extras:
            if dep.extras and dep.manager == "conda":
                warnings.warn(f"Extras not supported in Conda dep {dep}")
            else:
                matchspec["extras"] = dep.extras
        if len(matchspec) == 1:
            # Use the simpler VersionSpec format if there's only a version.
            return f'{dep.name} = "{matchspec["version"]}"'
        else:
            return dep.name + " = " + json.dumps(matchspec)
    elif isinstance(dep, URLDependency):
        raise NotImplementedError(f"URL not yet supported in {dep}")
    elif isinstance(dep, VCSDependency):
        raise NotImplementedError(f"VCS not yet supported in {dep}")
    else:
        raise ValueError(f"Unknown dependency type {dep}")


def aggregate_platform_independent_deps(
    dependencies: Dict[str, List[Dependency]],
) -> Tuple[Dict[DepKeyNoPlatform, Dependency], Dict[FullDepKey, Dependency]]:
    """Aggregate platform-independent dependencies."""
    all_platform_deps: Dict[DepKeyNoPlatform, Dependency] = {}
    platform_specific_deps: Dict[FullDepKey, Dependency] = {}

    num_platforms = len(dependencies.keys())

    indexed_deps: Dict[FullDepKey, Dependency] = {}
    for platform, deps in dependencies.items():
        for dep in deps:
            key = FullDepKey(
                name=dep.name,
                category=dep.category,
                platform=platform,
                manager=dep.manager,
            )
            if key in indexed_deps:
                raise ValueError(
                    f"Duplicate dependency {key}: {dep}, {indexed_deps[key]}"
                )
            indexed_deps[key] = dep

    # Collect by platform
    aggregated_deps: Dict[DepKeyNoPlatform, List[DepWithPlatform]] = defaultdict(list)
    for key1, dep in indexed_deps.items():
        key2 = DepKeyNoPlatform(
            name=key1.name, category=key1.category, manager=key1.manager
        )
        aggregated_deps[key2].append(DepWithPlatform(dep=dep, platform=key1.platform))

    # Check for all-arch dependencies
    for key2, deps_with_platforms in aggregated_deps.items():
        # It's all-arch if there's a dep for each platform and they're all the same.
        is_allarch = len(deps_with_platforms) == num_platforms and all(
            curr.dep == next.dep
            for curr, next in zip(deps_with_platforms, deps_with_platforms[1:])
        )
        if is_allarch:
            all_platform_deps[key2] = deps_with_platforms[0].dep
        else:
            for dep_with_platform in deps_with_platforms:
                key1 = FullDepKey(
                    name=key2.name,
                    category=key2.category,
                    platform=dep_with_platform.platform,
                    manager=key2.manager,
                )
                platform_specific_deps[key1] = dep_with_platform.dep
    return all_platform_deps, platform_specific_deps


def arrange_for_toml(
    lock_spec: LockSpecification,
) -> Dict[TomlTableKey, Dict[str, Dependency]]:
    """Arrange dependencies into a structured dictionary for TOML generation."""
    all_platform_deps, platform_specific_deps = aggregate_platform_independent_deps(
        lock_spec.dependencies
    )
    unsorted_result: Dict[TomlTableKey, Dict[str, Dependency]] = defaultdict(dict)
    for key, dep in platform_specific_deps.items():
        toml_key = TomlTableKey(
            category=key.category, platform=key.platform, manager=key.manager
        )
        if key.name in unsorted_result[toml_key]:
            preexisting_dep = unsorted_result[toml_key][key.name]
            raise ValueError(f"Duplicate key {key} for {dep} and {preexisting_dep}")
        unsorted_result[toml_key][key.name] = dep

    for key2, dep in all_platform_deps.items():
        toml_key = TomlTableKey(
            category=key2.category, platform=None, manager=key2.manager
        )
        if key2.name in unsorted_result[toml_key]:
            preexisting_dep = unsorted_result[toml_key][key2.name]
            raise ValueError(f"Duplicate key {key2} for {dep} and {preexisting_dep}")
        unsorted_result[toml_key][key2.name] = dep

    alphabetized_result = {
        toml_key: dict(sorted(deps_by_name.items()))
        for toml_key, deps_by_name in unsorted_result.items()
    }
    sorted_result = dict(sorted(alphabetized_result.items(), key=toml_ordering))
    return sorted_result


def toml_ordering(item: Tuple[TomlTableKey, dict]) -> Tuple[str, str, str]:
    """Make a sort key to properly order the dependency tables in the pixi.toml.

    The main category = default feature comes first. Then the other categories.

    Within each category, the platform-independent dependencies come first, followed by
    the platform-specific dependencies.

    Within each platform, we declare the conda dependencies first, followed by the pip
    dependencies.

    Within each table determined by the hierarchy of category, platform, and manager,
    the dependencies are sorted alphabetically by name. But the key here is just for
    sorting the tables that occur, not the dependencies within them.

    We define the ordering via a tuple of strings: (category, platform, manager).
    The main category and the platform-independent dependencies are represented by
    empty strings so that they come lexicographically first.

    >>> toml_ordering(
    ...     (TomlTableKey(category="main", platform=None, manager="conda"), {})
    ... )
    ('', '', 'conda')

    >>> toml_ordering(
    ...     (TomlTableKey(category="main", platform="linux-64", manager="conda"), {})
    ... )
    ('', 'linux-64', 'conda')

    >>> toml_ordering((TomlTableKey(category="dev", platform=None, manager="pip"), {}))
    ('dev', '', 'pip')
    """
    key = item[0]
    category = "" if key.category in ["main", "default"] else key.category
    platform = key.platform if key.platform is not None else ""
    # "conda" before "pip" is conveniently already lexicographical order.
    return category, platform, key.manager


def toml_header_line(key: TomlTableKey) -> str:
    """Generates a TOML header based on the dependency type, platform, and manager.

    >>> toml_header_line(
    ...     TomlTableKey(category="main", platform=None, manager="conda")
    ... )
    '[dependencies]'

    >>> toml_header_line(
    ...     TomlTableKey(category="main", platform="linux-64", manager="conda")
    ... )
    '[target.linux-64.dependencies]'

    >>> toml_header_line(TomlTableKey(category="main", platform=None, manager="pip"))
    '[pypi-dependencies]'

    >>> toml_header_line(
    ...     TomlTableKey(category="main", platform="linux-64", manager="pip")
    ... )
    '[target.linux-64.pypi-dependencies]'

    >>> toml_header_line(TomlTableKey(category="dev", platform=None, manager="conda"))
    '[feature.dev.dependencies]'

    >>> toml_header_line(
    ...     TomlTableKey(category="dev", platform="linux-64", manager="conda")
    ... )
    '[feature.dev.target.linux-64.dependencies]'

    >>> toml_header_line(TomlTableKey(category="dev", platform=None, manager="pip"))
    '[feature.dev.pypi-dependencies]'

    >>> toml_header_line(
    ...     TomlTableKey(category="dev", platform="linux-64", manager="pip")
    ... )
    '[feature.dev.target.linux-64.pypi-dependencies]'
    """
    parts = []
    if key.category not in ["main", "default"]:
        parts.extend(["feature", key.category])
    if key.platform:
        parts.extend(["target", key.platform])
    parts.append("dependencies" if key.manager == "conda" else "pypi-dependencies")
    return "[" + ".".join(parts) + "]"
